/* File: radsimmodule.c
 * This file is auto-generated with f2py (version:1.21.2).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date: Fri Sep  9 23:06:47 2022
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern "C" {
#endif

/*********************** See f2py2e/cfuncs.py: includes ***********************/
#include "Python.h"
#include <stdarg.h>
#include "fortranobject.h"
#include <math.h>

/**************** See f2py2e/rules.py: mod_rules['modulebody'] ****************/
static PyObject *radsim_error;
static PyObject *radsim_module;

/*********************** See f2py2e/cfuncs.py: typedefs ***********************/
typedef signed char signed_char;

/****************** See f2py2e/cfuncs.py: typedefs_generated ******************/
/*need_typedefs_generated*/

/********************** See f2py2e/cfuncs.py: cppmacros **********************/
#define pyobj_from_double1(v) (PyFloat_FromDouble(v))
#define PRINTPYOBJERR(obj)\
    fprintf(stderr,"radsim.error is related to ");\
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");

#define pyobj_from_int1(v) (PyLong_FromLong(v))
#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F
#else
#define F_FUNC(f,F) _##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F##_
#else
#define F_FUNC(f,F) _##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F
#else
#define F_FUNC(f,F) f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F##_
#else
#define F_FUNC(f,F) f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_)
#else
#define F_FUNC_US(f,F) F_FUNC(f,F)
#endif

#define rank(var) var ## _Rank
#define shape(var,dim) var ## _Dims[dim]
#define old_rank(var) (PyArray_NDIM((PyArrayObject *)(capi_ ## var ## _tmp)))
#define old_shape(var,dim) PyArray_DIM(((PyArrayObject *)(capi_ ## var ## _tmp)),dim)
#define fshape(var,dim) shape(var,rank(var)-dim-1)
#define len(var) shape(var,0)
#define flen(var) fshape(var,0)
#define old_size(var) PyArray_SIZE((PyArrayObject *)(capi_ ## var ## _tmp))
/* #define index(i) capi_i ## i */
#define slen(var) capi_ ## var ## _len
#define size(var, ...) f2py_size((PyArrayObject *)(capi_ ## var ## _tmp), ## __VA_ARGS__, -1)

#define CHECKSCALAR(check,tcheck,name,show,var)\
    if (!(check)) {\
        char errstring[256];\
        sprintf(errstring, "%s: "show, "("tcheck") failed for "name, var);\
        PyErr_SetString(radsim_error,errstring);\
        /*goto capi_fail;*/\
    } else 
#ifdef DEBUGCFUNCS
#define CFUNCSMESS(mess) fprintf(stderr,"debug-capi:"mess);
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) \
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");
#else
#define CFUNCSMESS(mess)
#define CFUNCSMESSPY(mess,obj)
#endif

#ifndef max
#define max(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a < b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b) ((a < b) ? (a) : (b))
#endif

#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_WRAPPEDFUNC(f,F) _F2PYWRAP##F
#else
#define F_WRAPPEDFUNC(f,F) _f2pywrap##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_WRAPPEDFUNC(f,F) _F2PYWRAP##F##_
#else
#define F_WRAPPEDFUNC(f,F) _f2pywrap##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_WRAPPEDFUNC(f,F) F2PYWRAP##F
#else
#define F_WRAPPEDFUNC(f,F) f2pywrap##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_WRAPPEDFUNC(f,F) F2PYWRAP##F##_
#else
#define F_WRAPPEDFUNC(f,F) f2pywrap##f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_WRAPPEDFUNC_US(f,F) F_WRAPPEDFUNC(f##_,F##_)
#else
#define F_WRAPPEDFUNC_US(f,F) F_WRAPPEDFUNC(f,F)
#endif

/* New SciPy */
#define TRYPYARRAYTEMPLATECHAR case NPY_STRING: *(char *)(PyArray_DATA(arr))=*v; break;
#define TRYPYARRAYTEMPLATELONG case NPY_LONG: *(long *)(PyArray_DATA(arr))=*v; break;
#define TRYPYARRAYTEMPLATEOBJECT case NPY_OBJECT: PyArray_SETITEM(arr,PyArray_DATA(arr),pyobj_from_ ## ctype ## 1(*v)); break;

#define TRYPYARRAYTEMPLATE(ctype,typecode) \
        PyArrayObject *arr = NULL;\
        if (!obj) return -2;\
        if (!PyArray_Check(obj)) return -1;\
        if (!(arr=(PyArrayObject *)obj)) {fprintf(stderr,"TRYPYARRAYTEMPLATE:");PRINTPYOBJERR(obj);return 0;}\
        if (PyArray_DESCR(arr)->type==typecode)  {*(ctype *)(PyArray_DATA(arr))=*v; return 1;}\
        switch (PyArray_TYPE(arr)) {\
                case NPY_DOUBLE: *(double *)(PyArray_DATA(arr))=*v; break;\
                case NPY_INT: *(int *)(PyArray_DATA(arr))=*v; break;\
                case NPY_LONG: *(long *)(PyArray_DATA(arr))=*v; break;\
                case NPY_FLOAT: *(float *)(PyArray_DATA(arr))=*v; break;\
                case NPY_CDOUBLE: *(double *)(PyArray_DATA(arr))=*v; break;\
                case NPY_CFLOAT: *(float *)(PyArray_DATA(arr))=*v; break;\
                case NPY_BOOL: *(npy_bool *)(PyArray_DATA(arr))=(*v!=0); break;\
                case NPY_UBYTE: *(unsigned char *)(PyArray_DATA(arr))=*v; break;\
                case NPY_BYTE: *(signed char *)(PyArray_DATA(arr))=*v; break;\
                case NPY_SHORT: *(short *)(PyArray_DATA(arr))=*v; break;\
                case NPY_USHORT: *(npy_ushort *)(PyArray_DATA(arr))=*v; break;\
                case NPY_UINT: *(npy_uint *)(PyArray_DATA(arr))=*v; break;\
                case NPY_ULONG: *(npy_ulong *)(PyArray_DATA(arr))=*v; break;\
                case NPY_LONGLONG: *(npy_longlong *)(PyArray_DATA(arr))=*v; break;\
                case NPY_ULONGLONG: *(npy_ulonglong *)(PyArray_DATA(arr))=*v; break;\
                case NPY_LONGDOUBLE: *(npy_longdouble *)(PyArray_DATA(arr))=*v; break;\
                case NPY_CLONGDOUBLE: *(npy_longdouble *)(PyArray_DATA(arr))=*v; break;\
                case NPY_OBJECT: PyArray_SETITEM(arr, PyArray_DATA(arr), pyobj_from_ ## ctype ## 1(*v)); break;\
        default: return -2;\
        };\
        return 1


/************************ See f2py2e/cfuncs.py: cfuncs ************************/
static int f2py_size(PyArrayObject* var, ...)
{
  npy_int sz = 0;
  npy_int dim;
  npy_int rank;
  va_list argp;
  va_start(argp, var);
  dim = va_arg(argp, npy_int);
  if (dim==-1)
    {
      sz = PyArray_SIZE(var);
    }
  else
    {
      rank = PyArray_NDIM(var);
      if (dim>=1 && dim<=rank)
        sz = PyArray_DIM(var, dim-1);
      else
        fprintf(stderr, "f2py_size: 2nd argument value=%d fails to satisfy 1<=value<=%d. Result will be 0.\n", dim, rank);
    }
  va_end(argp);
  return sz;
}

static int try_pyarr_from_int(PyObject* obj,int* v) {
    TRYPYARRAYTEMPLATE(int,'i');
}

static int
double_from_pyobj(double* v, PyObject *obj, const char *errmess)
{
    PyObject* tmp = NULL;
    if (PyFloat_Check(obj)) {
        *v = PyFloat_AsDouble(obj);
        return !(*v == -1.0 && PyErr_Occurred());
    }

    tmp = PyNumber_Float(obj);
    if (tmp) {
        *v = PyFloat_AsDouble(tmp);
        Py_DECREF(tmp);
        return !(*v == -1.0 && PyErr_Occurred());
    }
    if (PyComplex_Check(obj))
        tmp = PyObject_GetAttrString(obj,"real");
    else if (PyBytes_Check(obj) || PyUnicode_Check(obj))
        /*pass*/;
    else if (PySequence_Check(obj))
        tmp = PySequence_GetItem(obj,0);
    if (tmp) {
        PyErr_Clear();
        if (double_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = radsim_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}

static int
int_from_pyobj(int* v, PyObject *obj, const char *errmess)
{
    PyObject* tmp = NULL;

    if (PyLong_Check(obj)) {
        *v = Npy__PyLong_AsInt(obj);
        return !(*v == -1 && PyErr_Occurred());
    }

    tmp = PyNumber_Long(obj);
    if (tmp) {
        *v = Npy__PyLong_AsInt(tmp);
        Py_DECREF(tmp);
        return !(*v == -1 && PyErr_Occurred());
    }

    if (PyComplex_Check(obj))
        tmp = PyObject_GetAttrString(obj,"real");
    else if (PyBytes_Check(obj) || PyUnicode_Check(obj))
        /*pass*/;
    else if (PySequence_Check(obj))
        tmp = PySequence_GetItem(obj, 0);
    if (tmp) {
        PyErr_Clear();
        if (int_from_pyobj(v, tmp, errmess)) {
            Py_DECREF(tmp);
            return 1;
        }
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err == NULL) {
            err = radsim_error;
        }
        PyErr_SetString(err, errmess);
    }
    return 0;
}

static int try_pyarr_from_double(PyObject* obj,double* v) {
    TRYPYARRAYTEMPLATE(double,'d');
}


/********************* See f2py2e/cfuncs.py: userincludes *********************/
/*need_userincludes*/

/********************* See f2py2e/capi_rules.py: usercode *********************/


/* See f2py2e/rules.py */
extern void F_FUNC(dsd,DSD)(double*,double*,int*,int*,double*,double*,double*,double*,double*,double*,double*,double*,int*,double*,double*,double*);
extern void F_FUNC_US(optical_sphere,OPTICAL_SPHERE)(double*,double*,int*,double*,int*,double*,double*,double*);
extern void F_FUNC(zeff,ZEFF)(double*,double*,double*,int*,double*,int*,double*,double*,double*,double*,double*);
extern void F_WRAPPEDFUNC(gases,GASES)(double*,double*,double*,double*,double*);
/*eof externroutines*/

/******************** See f2py2e/capi_rules.py: usercode1 ********************/


/******************* See f2py2e/cb_rules.py: buildcallback *******************/
/*need_callbacks*/

/*********************** See f2py2e/rules.py: buildapi ***********************/

/************************************ dsd ************************************/
static char doc_f2py_rout_radsim_dsd[] = "\
n = dsd(q,d,dtype,rho_a,tc,dmin,dmax,p1,p2,p3,fc,scaled,apm,bpm,[nsizes])\n\nWrapper for ``dsd``.\
\n\nParameters\n----------\n"
"q : input float\n"
"d : input rank-1 array('d') with bounds (nsizes)\n"
"dtype : input int\n"
"rho_a : input float\n"
"tc : input float\n"
"dmin : input float\n"
"dmax : input float\n"
"p1 : input float\n"
"p2 : input float\n"
"p3 : input float\n"
"fc : in/output rank-1 array('d') with bounds (nsizes)\n"
"scaled : in/output rank-0 array(int,'i')\n"
"apm : input float\n"
"bpm : input float\n"
"\nOther Parameters\n----------------\n"
"nsizes : input int, optional\n    Default: len(d)\n"
"\nReturns\n-------\n"
"n : rank-1 array('d') with bounds (nsizes)";
/* extern void F_FUNC(dsd,DSD)(double*,double*,int*,int*,double*,double*,double*,double*,double*,double*,double*,double*,int*,double*,double*,double*); */
static PyObject *f2py_rout_radsim_dsd(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,int*,double*,double*,double*,double*,double*,double*,double*,double*,int*,double*,double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double q = 0;
  PyObject *q_capi = Py_None;
  double *d = NULL;
  npy_intp d_Dims[1] = {-1};
  const int d_Rank = 1;
  PyArrayObject *capi_d_tmp = NULL;
  int capi_d_intent = 0;
  PyObject *d_capi = Py_None;
  int nsizes = 0;
  PyObject *nsizes_capi = Py_None;
  int dtype = 0;
  PyObject *dtype_capi = Py_None;
  double rho_a = 0;
  PyObject *rho_a_capi = Py_None;
  double tc = 0;
  PyObject *tc_capi = Py_None;
  double dmin = 0;
  PyObject *dmin_capi = Py_None;
  double dmax = 0;
  PyObject *dmax_capi = Py_None;
  double p1 = 0;
  PyObject *p1_capi = Py_None;
  double p2 = 0;
  PyObject *p2_capi = Py_None;
  double p3 = 0;
  PyObject *p3_capi = Py_None;
  double *fc = NULL;
  npy_intp fc_Dims[1] = {-1};
  const int fc_Rank = 1;
  PyArrayObject *capi_fc_tmp = NULL;
  int capi_fc_intent = 0;
  PyObject *fc_capi = Py_None;
  int scaled = 0;
  PyObject *scaled_capi = Py_None;
  double apm = 0;
  PyObject *apm_capi = Py_None;
  double bpm = 0;
  PyObject *bpm_capi = Py_None;
  double *n = NULL;
  npy_intp n_Dims[1] = {-1};
  const int n_Rank = 1;
  PyArrayObject *capi_n_tmp = NULL;
  int capi_n_intent = 0;
    static char *capi_kwlist[] = {"q","d","dtype","rho_a","tc","dmin","dmax","p1","p2","p3","fc","scaled","apm","bpm","nsizes",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOOOOOOOOOOOO|O:radsim.dsd",\
        capi_kwlist,&q_capi,&d_capi,&dtype_capi,&rho_a_capi,&tc_capi,&dmin_capi,&dmax_capi,&p1_capi,&p2_capi,&p3_capi,&fc_capi,&scaled_capi,&apm_capi,&bpm_capi,&nsizes_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable q */
    f2py_success = double_from_pyobj(&q,q_capi,"radsim.dsd() 1st argument (q) can't be converted to double");
  if (f2py_success) {
  /* Processing variable d */
  ;
  capi_d_intent |= F2PY_INTENT_IN;
  capi_d_tmp = array_from_pyobj(NPY_DOUBLE,d_Dims,d_Rank,capi_d_intent,d_capi);
  if (capi_d_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting 2nd argument `d' of radsim.dsd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    d = (double *)(PyArray_DATA(capi_d_tmp));

  /* Processing variable dtype */
    f2py_success = int_from_pyobj(&dtype,dtype_capi,"radsim.dsd() 3rd argument (dtype) can't be converted to int");
  if (f2py_success) {
  /* Processing variable rho_a */
    f2py_success = double_from_pyobj(&rho_a,rho_a_capi,"radsim.dsd() 4th argument (rho_a) can't be converted to double");
  if (f2py_success) {
  /* Processing variable tc */
    f2py_success = double_from_pyobj(&tc,tc_capi,"radsim.dsd() 5th argument (tc) can't be converted to double");
  if (f2py_success) {
  /* Processing variable dmin */
    f2py_success = double_from_pyobj(&dmin,dmin_capi,"radsim.dsd() 6th argument (dmin) can't be converted to double");
  if (f2py_success) {
  /* Processing variable dmax */
    f2py_success = double_from_pyobj(&dmax,dmax_capi,"radsim.dsd() 7th argument (dmax) can't be converted to double");
  if (f2py_success) {
  /* Processing variable p1 */
    f2py_success = double_from_pyobj(&p1,p1_capi,"radsim.dsd() 8th argument (p1) can't be converted to double");
  if (f2py_success) {
  /* Processing variable p2 */
    f2py_success = double_from_pyobj(&p2,p2_capi,"radsim.dsd() 9th argument (p2) can't be converted to double");
  if (f2py_success) {
  /* Processing variable p3 */
    f2py_success = double_from_pyobj(&p3,p3_capi,"radsim.dsd() 10th argument (p3) can't be converted to double");
  if (f2py_success) {
  /* Processing variable scaled */
    scaled = (int)PyObject_IsTrue(scaled_capi);
    f2py_success = 1;
  if (f2py_success) {
  /* Processing variable apm */
    f2py_success = double_from_pyobj(&apm,apm_capi,"radsim.dsd() 13rd argument (apm) can't be converted to double");
  if (f2py_success) {
  /* Processing variable bpm */
    f2py_success = double_from_pyobj(&bpm,bpm_capi,"radsim.dsd() 14th argument (bpm) can't be converted to double");
  if (f2py_success) {
  /* Processing variable nsizes */
  if (nsizes_capi == Py_None) nsizes = len(d); else
    f2py_success = int_from_pyobj(&nsizes,nsizes_capi,"radsim.dsd() 1st keyword (nsizes) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(d)>=nsizes,"len(d)>=nsizes","1st keyword nsizes","dsd:nsizes=%d",nsizes) {
  /* Processing variable fc */
  fc_Dims[0]=nsizes;
  capi_fc_intent |= F2PY_INTENT_INOUT;
  capi_fc_tmp = array_from_pyobj(NPY_DOUBLE,fc_Dims,fc_Rank,capi_fc_intent,fc_capi);
  if (capi_fc_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting 11st argument `fc' of radsim.dsd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    fc = (double *)(PyArray_DATA(capi_fc_tmp));

  /* Processing variable n */
  n_Dims[0]=nsizes;
  capi_n_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_n_tmp = array_from_pyobj(NPY_DOUBLE,n_Dims,n_Rank,capi_n_intent,Py_None);
  if (capi_n_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting hidden `n' of radsim.dsd to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    n = (double *)(PyArray_DATA(capi_n_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&q,d,&nsizes,&dtype,&rho_a,&tc,&dmin,&dmax,&p1,&p2,&p3,fc,&scaled,&apm,&bpm,n);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
  f2py_success = try_pyarr_from_int(scaled_capi,&scaled);
  if (f2py_success) {
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("N",capi_n_tmp);
/*closepyobjfrom*/
  } /*if (f2py_success) of scaled pyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_n_tmp == NULL) ... else of n*/
  /* End of cleaning variable n */
  if((PyObject *)capi_fc_tmp!=fc_capi) {
    Py_XDECREF(capi_fc_tmp); }
  }  /*if (capi_fc_tmp == NULL) ... else of fc*/
  /* End of cleaning variable fc */
  } /*CHECKSCALAR(len(d)>=nsizes)*/
  } /*if (f2py_success) of nsizes*/
  /* End of cleaning variable nsizes */
  } /*if (f2py_success) of bpm*/
  /* End of cleaning variable bpm */
  } /*if (f2py_success) of apm*/
  /* End of cleaning variable apm */
  } /*if (f2py_success) of scaled*/
  /* End of cleaning variable scaled */
  } /*if (f2py_success) of p3*/
  /* End of cleaning variable p3 */
  } /*if (f2py_success) of p2*/
  /* End of cleaning variable p2 */
  } /*if (f2py_success) of p1*/
  /* End of cleaning variable p1 */
  } /*if (f2py_success) of dmax*/
  /* End of cleaning variable dmax */
  } /*if (f2py_success) of dmin*/
  /* End of cleaning variable dmin */
  } /*if (f2py_success) of tc*/
  /* End of cleaning variable tc */
  } /*if (f2py_success) of rho_a*/
  /* End of cleaning variable rho_a */
  } /*if (f2py_success) of dtype*/
  /* End of cleaning variable dtype */
  if((PyObject *)capi_d_tmp!=d_capi) {
    Py_XDECREF(capi_d_tmp); }
  }  /*if (capi_d_tmp == NULL) ... else of d*/
  /* End of cleaning variable d */
  } /*if (f2py_success) of q*/
  /* End of cleaning variable q */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/********************************* end of dsd *********************************/

/******************************* optical_sphere *******************************/
static char doc_f2py_rout_radsim_optical_sphere[] = "\
qext,qbsca = optical_sphere(freq,d,tt,ice,rho_e,[nsizes])\n\nWrapper for ``optical_sphere``.\
\n\nParameters\n----------\n"
"freq : input float\n"
"d : input rank-1 array('d') with bounds (nsizes)\n"
"tt : input float\n"
"ice : input int\n"
"rho_e : input rank-1 array('d') with bounds (nsizes)\n"
"\nOther Parameters\n----------------\n"
"nsizes : input int, optional\n    Default: len(d)\n"
"\nReturns\n-------\n"
"qext : rank-1 array('d') with bounds (nsizes)\n"
"qbsca : rank-1 array('d') with bounds (nsizes)";
/* extern void F_FUNC_US(optical_sphere,OPTICAL_SPHERE)(double*,double*,int*,double*,int*,double*,double*,double*); */
static PyObject *f2py_rout_radsim_optical_sphere(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,double*,int*,double*,double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double freq = 0;
  PyObject *freq_capi = Py_None;
  double *d = NULL;
  npy_intp d_Dims[1] = {-1};
  const int d_Rank = 1;
  PyArrayObject *capi_d_tmp = NULL;
  int capi_d_intent = 0;
  PyObject *d_capi = Py_None;
  int nsizes = 0;
  PyObject *nsizes_capi = Py_None;
  double tt = 0;
  PyObject *tt_capi = Py_None;
  int ice = 0;
  PyObject *ice_capi = Py_None;
  double *rho_e = NULL;
  npy_intp rho_e_Dims[1] = {-1};
  const int rho_e_Rank = 1;
  PyArrayObject *capi_rho_e_tmp = NULL;
  int capi_rho_e_intent = 0;
  PyObject *rho_e_capi = Py_None;
  double *qext = NULL;
  npy_intp qext_Dims[1] = {-1};
  const int qext_Rank = 1;
  PyArrayObject *capi_qext_tmp = NULL;
  int capi_qext_intent = 0;
  double *qbsca = NULL;
  npy_intp qbsca_Dims[1] = {-1};
  const int qbsca_Rank = 1;
  PyArrayObject *capi_qbsca_tmp = NULL;
  int capi_qbsca_intent = 0;
    static char *capi_kwlist[] = {"freq","d","tt","ice","rho_e","nsizes",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOOO|O:radsim.optical_sphere",\
        capi_kwlist,&freq_capi,&d_capi,&tt_capi,&ice_capi,&rho_e_capi,&nsizes_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable freq */
    f2py_success = double_from_pyobj(&freq,freq_capi,"radsim.optical_sphere() 1st argument (freq) can't be converted to double");
  if (f2py_success) {
  /* Processing variable d */
  ;
  capi_d_intent |= F2PY_INTENT_IN;
  capi_d_tmp = array_from_pyobj(NPY_DOUBLE,d_Dims,d_Rank,capi_d_intent,d_capi);
  if (capi_d_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting 2nd argument `d' of radsim.optical_sphere to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    d = (double *)(PyArray_DATA(capi_d_tmp));

  /* Processing variable tt */
    f2py_success = double_from_pyobj(&tt,tt_capi,"radsim.optical_sphere() 3rd argument (tt) can't be converted to double");
  if (f2py_success) {
  /* Processing variable ice */
    f2py_success = int_from_pyobj(&ice,ice_capi,"radsim.optical_sphere() 4th argument (ice) can't be converted to int");
  if (f2py_success) {
  /* Processing variable nsizes */
  if (nsizes_capi == Py_None) nsizes = len(d); else
    f2py_success = int_from_pyobj(&nsizes,nsizes_capi,"radsim.optical_sphere() 1st keyword (nsizes) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(d)>=nsizes,"len(d)>=nsizes","1st keyword nsizes","optical_sphere:nsizes=%d",nsizes) {
  /* Processing variable rho_e */
  rho_e_Dims[0]=nsizes;
  capi_rho_e_intent |= F2PY_INTENT_IN;
  capi_rho_e_tmp = array_from_pyobj(NPY_DOUBLE,rho_e_Dims,rho_e_Rank,capi_rho_e_intent,rho_e_capi);
  if (capi_rho_e_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting 5th argument `rho_e' of radsim.optical_sphere to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    rho_e = (double *)(PyArray_DATA(capi_rho_e_tmp));

  /* Processing variable qext */
  qext_Dims[0]=nsizes;
  capi_qext_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_qext_tmp = array_from_pyobj(NPY_DOUBLE,qext_Dims,qext_Rank,capi_qext_intent,Py_None);
  if (capi_qext_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting hidden `qext' of radsim.optical_sphere to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    qext = (double *)(PyArray_DATA(capi_qext_tmp));

  /* Processing variable qbsca */
  qbsca_Dims[0]=nsizes;
  capi_qbsca_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_qbsca_tmp = array_from_pyobj(NPY_DOUBLE,qbsca_Dims,qbsca_Rank,capi_qbsca_intent,Py_None);
  if (capi_qbsca_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting hidden `qbsca' of radsim.optical_sphere to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    qbsca = (double *)(PyArray_DATA(capi_qbsca_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&freq,d,&nsizes,&tt,&ice,rho_e,qext,qbsca);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("NN",capi_qext_tmp,capi_qbsca_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_qbsca_tmp == NULL) ... else of qbsca*/
  /* End of cleaning variable qbsca */
  }  /*if (capi_qext_tmp == NULL) ... else of qext*/
  /* End of cleaning variable qext */
  if((PyObject *)capi_rho_e_tmp!=rho_e_capi) {
    Py_XDECREF(capi_rho_e_tmp); }
  }  /*if (capi_rho_e_tmp == NULL) ... else of rho_e*/
  /* End of cleaning variable rho_e */
  } /*CHECKSCALAR(len(d)>=nsizes)*/
  } /*if (f2py_success) of nsizes*/
  /* End of cleaning variable nsizes */
  } /*if (f2py_success) of ice*/
  /* End of cleaning variable ice */
  } /*if (f2py_success) of tt*/
  /* End of cleaning variable tt */
  if((PyObject *)capi_d_tmp!=d_capi) {
    Py_XDECREF(capi_d_tmp); }
  }  /*if (capi_d_tmp == NULL) ... else of d*/
  /* End of cleaning variable d */
  } /*if (f2py_success) of freq*/
  /* End of cleaning variable freq */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/*************************** end of optical_sphere ***************************/

/************************************ zeff ************************************/
static char doc_f2py_rout_radsim_zeff[] = "\
z_eff,z_ray,kr = zeff(freq,d,n,k2,xr,qext,qbsca,[nsizes])\n\nWrapper for ``zeff``.\
\n\nParameters\n----------\n"
"freq : input float\n"
"d : input rank-1 array('d') with bounds (nsizes)\n"
"n : input rank-1 array('d') with bounds (nsizes)\n"
"k2 : in/output rank-0 array(float,'d')\n"
"xr : input int\n"
"qext : input rank-1 array('d') with bounds (nsizes)\n"
"qbsca : input rank-1 array('d') with bounds (nsizes)\n"
"\nOther Parameters\n----------------\n"
"nsizes : input int, optional\n    Default: len(d)\n"
"\nReturns\n-------\n"
"z_eff : float\n"
"z_ray : float\n"
"kr : float";
/* extern void F_FUNC(zeff,ZEFF)(double*,double*,double*,int*,double*,int*,double*,double*,double*,double*,double*); */
static PyObject *f2py_rout_radsim_zeff(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*,double*,int*,double*,double*,double*,double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double freq = 0;
  PyObject *freq_capi = Py_None;
  double *d = NULL;
  npy_intp d_Dims[1] = {-1};
  const int d_Rank = 1;
  PyArrayObject *capi_d_tmp = NULL;
  int capi_d_intent = 0;
  PyObject *d_capi = Py_None;
  double *n = NULL;
  npy_intp n_Dims[1] = {-1};
  const int n_Rank = 1;
  PyArrayObject *capi_n_tmp = NULL;
  int capi_n_intent = 0;
  PyObject *n_capi = Py_None;
  int nsizes = 0;
  PyObject *nsizes_capi = Py_None;
  double k2 = 0;
  PyObject *k2_capi = Py_None;
  int xr = 0;
  PyObject *xr_capi = Py_None;
  double *qext = NULL;
  npy_intp qext_Dims[1] = {-1};
  const int qext_Rank = 1;
  PyArrayObject *capi_qext_tmp = NULL;
  int capi_qext_intent = 0;
  PyObject *qext_capi = Py_None;
  double *qbsca = NULL;
  npy_intp qbsca_Dims[1] = {-1};
  const int qbsca_Rank = 1;
  PyArrayObject *capi_qbsca_tmp = NULL;
  int capi_qbsca_intent = 0;
  PyObject *qbsca_capi = Py_None;
  double z_eff = 0;
  double z_ray = 0;
  double kr = 0;
    static char *capi_kwlist[] = {"freq","d","n","k2","xr","qext","qbsca","nsizes",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOOOOO|O:radsim.zeff",\
        capi_kwlist,&freq_capi,&d_capi,&n_capi,&k2_capi,&xr_capi,&qext_capi,&qbsca_capi,&nsizes_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable freq */
    f2py_success = double_from_pyobj(&freq,freq_capi,"radsim.zeff() 1st argument (freq) can't be converted to double");
  if (f2py_success) {
  /* Processing variable d */
  ;
  capi_d_intent |= F2PY_INTENT_IN;
  capi_d_tmp = array_from_pyobj(NPY_DOUBLE,d_Dims,d_Rank,capi_d_intent,d_capi);
  if (capi_d_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting 2nd argument `d' of radsim.zeff to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    d = (double *)(PyArray_DATA(capi_d_tmp));

  /* Processing variable k2 */
    f2py_success = double_from_pyobj(&k2,k2_capi,"radsim.zeff() 4th argument (k2) can't be converted to double");
  if (f2py_success) {
  /* Processing variable xr */
    f2py_success = int_from_pyobj(&xr,xr_capi,"radsim.zeff() 5th argument (xr) can't be converted to int");
  if (f2py_success) {
  /* Processing variable z_eff */
  /* Processing variable z_ray */
  /* Processing variable kr */
  /* Processing variable nsizes */
  if (nsizes_capi == Py_None) nsizes = len(d); else
    f2py_success = int_from_pyobj(&nsizes,nsizes_capi,"radsim.zeff() 1st keyword (nsizes) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(d)>=nsizes,"len(d)>=nsizes","1st keyword nsizes","zeff:nsizes=%d",nsizes) {
  /* Processing variable qext */
  qext_Dims[0]=nsizes;
  capi_qext_intent |= F2PY_INTENT_IN;
  capi_qext_tmp = array_from_pyobj(NPY_DOUBLE,qext_Dims,qext_Rank,capi_qext_intent,qext_capi);
  if (capi_qext_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting 6th argument `qext' of radsim.zeff to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    qext = (double *)(PyArray_DATA(capi_qext_tmp));

  /* Processing variable qbsca */
  qbsca_Dims[0]=nsizes;
  capi_qbsca_intent |= F2PY_INTENT_IN;
  capi_qbsca_tmp = array_from_pyobj(NPY_DOUBLE,qbsca_Dims,qbsca_Rank,capi_qbsca_intent,qbsca_capi);
  if (capi_qbsca_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting 7th argument `qbsca' of radsim.zeff to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    qbsca = (double *)(PyArray_DATA(capi_qbsca_tmp));

  /* Processing variable n */
  n_Dims[0]=nsizes;
  capi_n_intent |= F2PY_INTENT_IN;
  capi_n_tmp = array_from_pyobj(NPY_DOUBLE,n_Dims,n_Rank,capi_n_intent,n_capi);
  if (capi_n_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting 3rd argument `n' of radsim.zeff to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    n = (double *)(PyArray_DATA(capi_n_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&freq,d,n,&nsizes,&k2,&xr,qext,qbsca,&z_eff,&z_ray,&kr);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
  f2py_success = try_pyarr_from_double(k2_capi,&k2);
  if (f2py_success) {
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("ddd",z_eff,z_ray,kr);
/*closepyobjfrom*/
  } /*if (f2py_success) of k2 pyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_n_tmp!=n_capi) {
    Py_XDECREF(capi_n_tmp); }
  }  /*if (capi_n_tmp == NULL) ... else of n*/
  /* End of cleaning variable n */
  if((PyObject *)capi_qbsca_tmp!=qbsca_capi) {
    Py_XDECREF(capi_qbsca_tmp); }
  }  /*if (capi_qbsca_tmp == NULL) ... else of qbsca*/
  /* End of cleaning variable qbsca */
  if((PyObject *)capi_qext_tmp!=qext_capi) {
    Py_XDECREF(capi_qext_tmp); }
  }  /*if (capi_qext_tmp == NULL) ... else of qext*/
  /* End of cleaning variable qext */
  } /*CHECKSCALAR(len(d)>=nsizes)*/
  } /*if (f2py_success) of nsizes*/
  /* End of cleaning variable nsizes */
  /* End of cleaning variable kr */
  /* End of cleaning variable z_ray */
  /* End of cleaning variable z_eff */
  } /*if (f2py_success) of xr*/
  /* End of cleaning variable xr */
  } /*if (f2py_success) of k2*/
  /* End of cleaning variable k2 */
  if((PyObject *)capi_d_tmp!=d_capi) {
    Py_XDECREF(capi_d_tmp); }
  }  /*if (capi_d_tmp == NULL) ... else of d*/
  /* End of cleaning variable d */
  } /*if (f2py_success) of freq*/
  /* End of cleaning variable freq */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************** end of zeff ********************************/

/*********************************** gases ***********************************/
static char doc_f2py_rout_radsim_gases[] = "\
gases = gases(pres_mb,t,rh,f)\n\nWrapper for ``gases``.\
\n\nParameters\n----------\n"
"pres_mb : input float\n"
"t : input float\n"
"rh : input float\n"
"f : input float\n"
"\nReturns\n-------\n"
"gases : float";
/* extern void F_WRAPPEDFUNC(gases,GASES)(double*,double*,double*,double*,double*); */
static PyObject *f2py_rout_radsim_gases(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double gases = 0;
  double pres_mb = 0;
  PyObject *pres_mb_capi = Py_None;
  double t = 0;
  PyObject *t_capi = Py_None;
  double rh = 0;
  PyObject *rh_capi = Py_None;
  double f = 0;
  PyObject *f_capi = Py_None;
    static char *capi_kwlist[] = {"pres_mb","t","rh","f",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOO|:radsim.gases",\
        capi_kwlist,&pres_mb_capi,&t_capi,&rh_capi,&f_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable pres_mb */
    f2py_success = double_from_pyobj(&pres_mb,pres_mb_capi,"radsim.gases() 1st argument (pres_mb) can't be converted to double");
  if (f2py_success) {
  /* Processing variable t */
    f2py_success = double_from_pyobj(&t,t_capi,"radsim.gases() 2nd argument (t) can't be converted to double");
  if (f2py_success) {
  /* Processing variable rh */
    f2py_success = double_from_pyobj(&rh,rh_capi,"radsim.gases() 3rd argument (rh) can't be converted to double");
  if (f2py_success) {
  /* Processing variable f */
    f2py_success = double_from_pyobj(&f,f_capi,"radsim.gases() 4th argument (f) can't be converted to double");
  if (f2py_success) {
  /* Processing variable gases */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&gases,&pres_mb,&t,&rh,&f);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("d",gases);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable gases */
  } /*if (f2py_success) of f*/
  /* End of cleaning variable f */
  } /*if (f2py_success) of rh*/
  /* End of cleaning variable rh */
  } /*if (f2py_success) of t*/
  /* End of cleaning variable t */
  } /*if (f2py_success) of pres_mb*/
  /* End of cleaning variable pres_mb */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************** end of gases ********************************/

/*********************************** gamma ***********************************/
static char doc_f2py_rout_radsim_math_lib_gamma[] = "\
gamma = gamma(x)\n\nWrapper for ``gamma``.\
\n\nParameters\n----------\n"
"x : input float\n"
"\nReturns\n-------\n"
"gamma : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_radsim_math_lib_gamma(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double gamma = 0;
  double x = 0;
  PyObject *x_capi = Py_None;
    static char *capi_kwlist[] = {"x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "O|:radsim.math_lib.gamma",\
        capi_kwlist,&x_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable x */
    f2py_success = double_from_pyobj(&x,x_capi,"radsim.math_lib.gamma() 1st argument (x) can't be converted to double");
  if (f2py_success) {
  /* Processing variable gamma */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&gamma,&x);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("d",gamma);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable gamma */
  } /*if (f2py_success) of x*/
  /* End of cleaning variable x */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************** end of gamma ********************************/

/******************************* path_integral *******************************/
static char doc_f2py_rout_radsim_math_lib_path_integral[] = "\
path_integral = path_integral(f,s,i1,i2)\n\nWrapper for ``path_integral``.\
\n\nParameters\n----------\n"
"f : input rank-1 array('d') with bounds (f2py_f_d0)\n"
"s : input rank-1 array('d') with bounds (f2py_s_d0)\n"
"i1 : input int\n"
"i2 : input int\n"
"\nReturns\n-------\n"
"path_integral : float";
/* #declfortranroutine# */
static PyObject *f2py_rout_radsim_math_lib_path_integral(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*,int*,int*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double path_integral = 0;
  double *f = NULL;
  npy_intp f_Dims[1] = {-1};
  const int f_Rank = 1;
  PyArrayObject *capi_f_tmp = NULL;
  int capi_f_intent = 0;
  PyObject *f_capi = Py_None;
  double *s = NULL;
  npy_intp s_Dims[1] = {-1};
  const int s_Rank = 1;
  PyArrayObject *capi_s_tmp = NULL;
  int capi_s_intent = 0;
  PyObject *s_capi = Py_None;
  int i1 = 0;
  PyObject *i1_capi = Py_None;
  int i2 = 0;
  PyObject *i2_capi = Py_None;
  int f2py_f_d0 = 0;
  int f2py_s_d0 = 0;
    static char *capi_kwlist[] = {"f","s","i1","i2",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOO|:radsim.math_lib.path_integral",\
        capi_kwlist,&f_capi,&s_capi,&i1_capi,&i2_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable f */
  ;
  capi_f_intent |= F2PY_INTENT_IN;
  capi_f_tmp = array_from_pyobj(NPY_DOUBLE,f_Dims,f_Rank,capi_f_intent,f_capi);
  if (capi_f_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting 1st argument `f' of radsim.math_lib.path_integral to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    f = (double *)(PyArray_DATA(capi_f_tmp));

  /* Processing variable s */
  ;
  capi_s_intent |= F2PY_INTENT_IN;
  capi_s_tmp = array_from_pyobj(NPY_DOUBLE,s_Dims,s_Rank,capi_s_intent,s_capi);
  if (capi_s_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting 2nd argument `s' of radsim.math_lib.path_integral to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    s = (double *)(PyArray_DATA(capi_s_tmp));

  /* Processing variable i1 */
    f2py_success = int_from_pyobj(&i1,i1_capi,"radsim.math_lib.path_integral() 3rd argument (i1) can't be converted to int");
  if (f2py_success) {
  /* Processing variable i2 */
    f2py_success = int_from_pyobj(&i2,i2_capi,"radsim.math_lib.path_integral() 4th argument (i2) can't be converted to int");
  if (f2py_success) {
  /* Processing variable path_integral */
  /* Processing variable f2py_f_d0 */
  f2py_f_d0 = shape(f, 0);
  /* Processing variable f2py_s_d0 */
  f2py_s_d0 = shape(s, 0);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&path_integral,f,s,&i1,&i2,&f2py_f_d0,&f2py_s_d0);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("d",path_integral);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_s_d0 */
  /* End of cleaning variable f2py_f_d0 */
  /* End of cleaning variable path_integral */
  } /*if (f2py_success) of i2*/
  /* End of cleaning variable i2 */
  } /*if (f2py_success) of i1*/
  /* End of cleaning variable i1 */
  if((PyObject *)capi_s_tmp!=s_capi) {
    Py_XDECREF(capi_s_tmp); }
  }  /*if (capi_s_tmp == NULL) ... else of s*/
  /* End of cleaning variable s */
  if((PyObject *)capi_f_tmp!=f_capi) {
    Py_XDECREF(capi_f_tmp); }
  }  /*if (capi_f_tmp == NULL) ... else of f*/
  /* End of cleaning variable f */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/**************************** end of path_integral ****************************/

/*********************************** avint ***********************************/
static char doc_f2py_rout_radsim_math_lib_avint[] = "\
result = avint(ftab,xtab,a_in,b_in,[ntab])\n\nWrapper for ``avint``.\
\n\nParameters\n----------\n"
"ftab : input rank-1 array('d') with bounds (ntab)\n"
"xtab : input rank-1 array('d') with bounds (ntab)\n"
"a_in : input float\n"
"b_in : input float\n"
"\nOther Parameters\n----------------\n"
"ntab : input int, optional\n    Default: len(ftab)\n"
"\nReturns\n-------\n"
"result : float";
/*  */
static PyObject *f2py_rout_radsim_math_lib_avint(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,double*,double*,double*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  double *ftab = NULL;
  npy_intp ftab_Dims[1] = {-1};
  const int ftab_Rank = 1;
  PyArrayObject *capi_ftab_tmp = NULL;
  int capi_ftab_intent = 0;
  PyObject *ftab_capi = Py_None;
  double *xtab = NULL;
  npy_intp xtab_Dims[1] = {-1};
  const int xtab_Rank = 1;
  PyArrayObject *capi_xtab_tmp = NULL;
  int capi_xtab_intent = 0;
  PyObject *xtab_capi = Py_None;
  int ntab = 0;
  PyObject *ntab_capi = Py_None;
  double a_in = 0;
  PyObject *a_in_capi = Py_None;
  double b_in = 0;
  PyObject *b_in_capi = Py_None;
  double result = 0;
    static char *capi_kwlist[] = {"ftab","xtab","a_in","b_in","ntab",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOO|O:radsim.math_lib.avint",\
        capi_kwlist,&ftab_capi,&xtab_capi,&a_in_capi,&b_in_capi,&ntab_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable ftab */
  ;
  capi_ftab_intent |= F2PY_INTENT_IN;
  capi_ftab_tmp = array_from_pyobj(NPY_DOUBLE,ftab_Dims,ftab_Rank,capi_ftab_intent,ftab_capi);
  if (capi_ftab_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting 1st argument `ftab' of radsim.math_lib.avint to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    ftab = (double *)(PyArray_DATA(capi_ftab_tmp));

  /* Processing variable a_in */
    f2py_success = double_from_pyobj(&a_in,a_in_capi,"radsim.math_lib.avint() 3rd argument (a_in) can't be converted to double");
  if (f2py_success) {
  /* Processing variable b_in */
    f2py_success = double_from_pyobj(&b_in,b_in_capi,"radsim.math_lib.avint() 4th argument (b_in) can't be converted to double");
  if (f2py_success) {
  /* Processing variable result */
  /* Processing variable ntab */
  if (ntab_capi == Py_None) ntab = len(ftab); else
    f2py_success = int_from_pyobj(&ntab,ntab_capi,"radsim.math_lib.avint() 1st keyword (ntab) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(ftab)>=ntab,"len(ftab)>=ntab","1st keyword ntab","avint:ntab=%d",ntab) {
  /* Processing variable xtab */
  xtab_Dims[0]=ntab;
  capi_xtab_intent |= F2PY_INTENT_IN;
  capi_xtab_tmp = array_from_pyobj(NPY_DOUBLE,xtab_Dims,xtab_Rank,capi_xtab_intent,xtab_capi);
  if (capi_xtab_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : radsim_error,"failed in converting 2nd argument `xtab' of radsim.math_lib.avint to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    xtab = (double *)(PyArray_DATA(capi_xtab_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(ftab,xtab,&ntab,&a_in,&b_in,&result);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("d",result);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_xtab_tmp!=xtab_capi) {
    Py_XDECREF(capi_xtab_tmp); }
  }  /*if (capi_xtab_tmp == NULL) ... else of xtab*/
  /* End of cleaning variable xtab */
  } /*CHECKSCALAR(len(ftab)>=ntab)*/
  } /*if (f2py_success) of ntab*/
  /* End of cleaning variable ntab */
  /* End of cleaning variable result */
  } /*if (f2py_success) of b_in*/
  /* End of cleaning variable b_in */
  } /*if (f2py_success) of a_in*/
  /* End of cleaning variable a_in */
  if((PyObject *)capi_ftab_tmp!=ftab_capi) {
    Py_XDECREF(capi_ftab_tmp); }
  }  /*if (capi_ftab_tmp == NULL) ... else of ftab*/
  /* End of cleaning variable ftab */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/******************************** end of avint ********************************/

/********************************* vals_equal *********************************/
static char doc_f2py_rout_radsim_math_lib_vals_equal[] = "\
vals_equal = vals_equal(val1,val2)\n\nWrapper for ``vals_equal``.\
\n\nParameters\n----------\n"
"val1 : input float\n"
"val2 : input int\n"
"\nReturns\n-------\n"
"vals_equal : int";
/* #declfortranroutine# */
static PyObject *f2py_rout_radsim_math_lib_vals_equal(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int vals_equal = 0;
  double val1 = 0;
  PyObject *val1_capi = Py_None;
  int val2 = 0;
  PyObject *val2_capi = Py_None;
    static char *capi_kwlist[] = {"val1","val2",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|:radsim.math_lib.vals_equal",\
        capi_kwlist,&val1_capi,&val2_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable val1 */
    f2py_success = double_from_pyobj(&val1,val1_capi,"radsim.math_lib.vals_equal() 1st argument (val1) can't be converted to double");
  if (f2py_success) {
  /* Processing variable val2 */
    f2py_success = int_from_pyobj(&val2,val2_capi,"radsim.math_lib.vals_equal() 2nd argument (val2) can't be converted to int");
  if (f2py_success) {
  /* Processing variable vals_equal */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&vals_equal,&val1,&val2);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("i",vals_equal);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable vals_equal */
  } /*if (f2py_success) of val2*/
  /* End of cleaning variable val2 */
  } /*if (f2py_success) of val1*/
  /* End of cleaning variable val1 */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of vals_equal *****************************/

/******************************** vals_differ ********************************/
static char doc_f2py_rout_radsim_math_lib_vals_differ[] = "\
vals_differ = vals_differ(val1,val2)\n\nWrapper for ``vals_differ``.\
\n\nParameters\n----------\n"
"val1 : input float\n"
"val2 : input int\n"
"\nReturns\n-------\n"
"vals_differ : int";
/* #declfortranroutine# */
static PyObject *f2py_rout_radsim_math_lib_vals_differ(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,double*,int*)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

  int vals_differ = 0;
  double val1 = 0;
  PyObject *val1_capi = Py_None;
  int val2 = 0;
  PyObject *val2_capi = Py_None;
    static char *capi_kwlist[] = {"val1","val2",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OO|:radsim.math_lib.vals_differ",\
        capi_kwlist,&val1_capi,&val2_capi))
        return NULL;
/*frompyobj*/
  /* Processing variable val1 */
    f2py_success = double_from_pyobj(&val1,val1_capi,"radsim.math_lib.vals_differ() 1st argument (val1) can't be converted to double");
  if (f2py_success) {
  /* Processing variable val2 */
    f2py_success = int_from_pyobj(&val2,val2_capi,"radsim.math_lib.vals_differ() 2nd argument (val2) can't be converted to int");
  if (f2py_success) {
  /* Processing variable vals_differ */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&vals_differ,&val1,&val2);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        CFUNCSMESS("Building return value.\n");
        capi_buildvalue = Py_BuildValue("i",vals_differ);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable vals_differ */
  } /*if (f2py_success) of val2*/
  /* End of cleaning variable val2 */
  } /*if (f2py_success) of val1*/
  /* End of cleaning variable val1 */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
    CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/***************************** end of vals_differ *****************************/
/*eof body*/

/******************* See f2py2e/f90mod_rules.py: buildhooks *******************/

static FortranDataDef f2py_math_lib_def[] = {
  {"gamma",-1,{{-1}},0,NULL,(void *)f2py_rout_radsim_math_lib_gamma,doc_f2py_rout_radsim_math_lib_gamma},
  {"path_integral",-1,{{-1}},0,NULL,(void *)f2py_rout_radsim_math_lib_path_integral,doc_f2py_rout_radsim_math_lib_path_integral},
  {"avint",-1,{{-1}},0,NULL,(void *)f2py_rout_radsim_math_lib_avint,doc_f2py_rout_radsim_math_lib_avint},
  {"vals_equal",-1,{{-1}},0,NULL,(void *)f2py_rout_radsim_math_lib_vals_equal,doc_f2py_rout_radsim_math_lib_vals_equal},
  {"vals_differ",-1,{{-1}},0,NULL,(void *)f2py_rout_radsim_math_lib_vals_differ,doc_f2py_rout_radsim_math_lib_vals_differ},
  {NULL}
};

static void f2py_setup_math_lib(char *gamma,char *path_integral,char *avint,char *vals_equal,char *vals_differ) {
  int i_f2py=0;
  f2py_math_lib_def[i_f2py++].data = gamma;
  f2py_math_lib_def[i_f2py++].data = path_integral;
  f2py_math_lib_def[i_f2py++].data = avint;
  f2py_math_lib_def[i_f2py++].data = vals_equal;
  f2py_math_lib_def[i_f2py++].data = vals_differ;
}
extern void F_FUNC_US(f2pyinitmath_lib,F2PYINITMATH_LIB)(void (*)(char *,char *,char *,char *,char *));
static void f2py_init_math_lib(void) {
  F_FUNC_US(f2pyinitmath_lib,F2PYINITMATH_LIB)(f2py_setup_math_lib);
}

/*need_f90modhooks*/

/************** See f2py2e/rules.py: module_rules['modulebody'] **************/

/******************* See f2py2e/common_rules.py: buildhooks *******************/

/*need_commonhooks*/

/**************************** See f2py2e/rules.py ****************************/

static FortranDataDef f2py_routine_defs[] = {
  {"dsd",-1,{{-1}},0,(char *)F_FUNC(dsd,DSD),(f2py_init_func)f2py_rout_radsim_dsd,doc_f2py_rout_radsim_dsd},
  {"optical_sphere",-1,{{-1}},0,(char *)F_FUNC_US(optical_sphere,OPTICAL_SPHERE),(f2py_init_func)f2py_rout_radsim_optical_sphere,doc_f2py_rout_radsim_optical_sphere},
  {"zeff",-1,{{-1}},0,(char *)F_FUNC(zeff,ZEFF),(f2py_init_func)f2py_rout_radsim_zeff,doc_f2py_rout_radsim_zeff},
  {"gases",-1,{{-1}},0,(char *)F_WRAPPEDFUNC(gases,GASES),(f2py_init_func)f2py_rout_radsim_gases,doc_f2py_rout_radsim_gases},

/*eof routine_defs*/
  {NULL}
};

static PyMethodDef f2py_module_methods[] = {

  {NULL,NULL}
};

static struct PyModuleDef moduledef = {
  PyModuleDef_HEAD_INIT,
  "radsim",
  NULL,
  -1,
  f2py_module_methods,
  NULL,
  NULL,
  NULL,
  NULL
};

PyMODINIT_FUNC PyInit_radsim(void) {
  int i;
  PyObject *m,*d, *s, *tmp;
  m = radsim_module = PyModule_Create(&moduledef);
  Py_SET_TYPE(&PyFortran_Type, &PyType_Type);
  import_array();
  if (PyErr_Occurred())
    {PyErr_SetString(PyExc_ImportError, "can't initialize module radsim (failed to import numpy)"); return m;}
  d = PyModule_GetDict(m);
  s = PyUnicode_FromString("1.21.2");
  PyDict_SetItemString(d, "__version__", s);
  Py_DECREF(s);
  s = PyUnicode_FromString(
    "This module 'radsim' is auto-generated with f2py (version:1.21.2).\nFunctions:\n"
"  n = dsd(q,d,dtype,rho_a,tc,dmin,dmax,p1,p2,p3,fc,scaled,apm,bpm,nsizes=len(d))\n"
"  qext,qbsca = optical_sphere(freq,d,tt,ice,rho_e,nsizes=len(d))\n"
"  z_eff,z_ray,kr = zeff(freq,d,n,k2,xr,qext,qbsca,nsizes=len(d))\n"
"  gases = gases(pres_mb,t,rh,f)\n"
"Fortran 90/95 modules:\n""  math_lib --- gamma(),path_integral(),avint(),vals_equal(),vals_differ()"".");
  PyDict_SetItemString(d, "__doc__", s);
  Py_DECREF(s);
  s = PyUnicode_FromString("1.21.2");
  PyDict_SetItemString(d, "__f2py_numpy_version__", s);
  Py_DECREF(s);
  radsim_error = PyErr_NewException ("radsim.error", NULL, NULL);
  /*
   * Store the error object inside the dict, so that it could get deallocated.
   * (in practice, this is a module, so it likely will not and cannot.)
   */
  PyDict_SetItemString(d, "_radsim_error", radsim_error);
  Py_DECREF(radsim_error);
  for(i=0;f2py_routine_defs[i].name!=NULL;i++) {
    tmp = PyFortranObject_NewAsAttr(&f2py_routine_defs[i]);
    PyDict_SetItemString(d, f2py_routine_defs[i].name, tmp);
    Py_DECREF(tmp);
  }




    {
      extern double F_FUNC(gases,GASES)(void);
      PyObject* o = PyDict_GetItemString(d,"gases");
      tmp = F2PyCapsule_FromVoidPtr((void*)F_FUNC(gases,GASES),NULL);
      PyObject_SetAttrString(o,"_cpointer", tmp);
      Py_DECREF(tmp);
      s = PyUnicode_FromString("gases");
      PyObject_SetAttrString(o,"__name__", s);
      Py_DECREF(s);
    }
    





/*eof initf2pywraphooks*/
  PyDict_SetItemString(d, "math_lib", PyFortranObject_New(f2py_math_lib_def,f2py_init_math_lib));
/*eof initf90modhooks*/

/*eof initcommonhooks*/


#ifdef F2PY_REPORT_ATEXIT
  if (! PyErr_Occurred())
    on_exit(f2py_report_on_exit,(void*)"radsim");
#endif
  return m;
}
#ifdef __cplusplus
}
#endif
